# Virtru Tagging PDP Configuration
# Map and normalize terms extracted from the tag processors

classificationAttributeFQN: &classificationAttributeFQN "https://demo.com/attr/classification"
needToKnowAttributeFQN: &needToKnowAttributeFQN "https://demo.com/attr/needtoknow"
relToAttributeFQN: &relToAttributeFQN "https://demo.com/attr/relto"
sciAttributeFQN: &sciAttributeFQN "https://demo.com/attr/sci"
coiAttributeFQN: &coiAttributeFQN "https://demo.com/attr/poi"
pcoiAttributeFQN: &pcoiAttributeFQN "https://demo.com/attr/pcoi"

ATTRIBUTE_RULE_TYPE_ENUM_ALL_OF: &ATTRIBUTE_RULE_TYPE_ENUM_ALL_OF 1
ATTRIBUTE_RULE_TYPE_ENUM_ANY_OF: &ATTRIBUTE_RULE_TYPE_ENUM_ANY_OF 2
ATTRIBUTE_RULE_TYPE_ENUM_HIERARCHY: &ATTRIBUTE_RULE_TYPE_ENUM_HIERARCHY 3


#Mappings from STANAG Classifications to IC-EDH enum compatible values
ic-edh-cls-mappings: &ic-edh-cls-mappings
  - key: RESTRICTED
    value: R
  - key: CONFIDENTIAL
    value: C
  - key: SECRET
    value: S
  - key: TOP SECRET
    value: TS
  - key: UNCLASSIFIED
    value: U

resourceMappingSets:
  # Entries mapping synonyms to one or more normalized terms.
  - id: "classification-dict"
    entries:
      - terms: ["TS", "TOP SECRET", "TOPSECRET"]
        attributevalue:
          value: "topsecret"
      - terms: ["S", "SECRET", "SEC"]
        attributevalue:
          value: "secret"
      - terms: ["C", "CONFIDENTIAL", "CONTROLLED UNCLASSIFIED",
                   "OFFICIAL-SENSITIVE", "CUI"]
        attributevalue:
          value: "confidential"
      - terms: ["U", "UNCLASSIFIED", "OFFICIAL"]
        attributevalue:
          value: "unclassified"
  - id: "relto-dict"
    entries:
      - terms: ["US"]
        attributevalue:
          value: "USA"
      - terms: ["UK"]
        attributevalue:
          value: "GBR"
  - id: "abac-to-snag4774"
    entries:
      - terms: ["Releasable To"]
        attributevalue:
          attribute:
            fqn: *relToAttributeFQN
      - terms: ["TOP SECRET"]
        attributevalue:
          fqn: "https://demo.com/attr/classification/value/topsecret"
      - terms: ["SECRET"]
        attributevalue:
          fqn: "https://demo.com/attr/classification/value/secret"
      - terms: ["UNCLASSIFIED"]
        attributevalue:
          fqn: "https://demo.com/attr/classification/value/unclassified"
      - terms: ["CONFIDENTIAL"]
        attributevalue:
          fqn: "https://demo.com/attr/classification/value/confidential"

icEDHSecAccessMappings: &icEDHSecAccessMappings
  # Mapping of EDH Security Access values for ism:classification
  - ismAttribute: classification
    # Optional Handling Statement Scope: ALL|TOD|PAYL; default=ALL
    #scope:
    # The tag templates
    mappings:
      # Optional flag for requiring tag templates have a synonym match. default = false
      # synonymDictionaryMatch: true
      tagTemplates:
        - type: "ATTRIBUTE"
          synonymDictionary: "classification-dict"
          namespace: *classificationAttributeFQN
  # Mapping of EDH Security Access values for ism:releasableTo
  - ismAttribute: releasableTo
    mappings:
      delimiters: [ ",",";"," " ]
      tagTemplates:
        - type: "ATTRIBUTE"
          namespace: *relToAttributeFQN
  - ismAttribute: SCIcontrols
    mappings:
      delimiters: [ ",",";"," " ]
      tagTemplates:
        - type: "ATTRIBUTE"
          namespace: *sciAttributeFQN
  - ismAttribute: SARIdentifier
    mappings:
      delimiters: [ ",",";"," " ]
      synonymDictionaryMatch: true
      tagTemplates:
        - type: "ATTRIBUTE"
          namespace: *coiAttributeFQN
          synonymDictionary: "coi-dict"
        - type: "ATTRIBUTE"
          namespace: *pcoiAttributeFQN
          synonymDictionary: "pcoi-dict"

snag5636-attributeInputs: &snag5636-attributeInputs
  classificationFQN: *classificationAttributeFQN
  mapAllAttributeToCategory: false
  requireMappedAttributes: false
  categoryFQNs:
    - *relToAttributeFQN
    - *needToKnowAttributeFQN
    - *sciAttributeFQN
  resourceMappingSet: "abac-to-snag4774"

ismNamespace: &ismNamespace "urn:us:gov:ic:ism"
agencyNamespace: &agencyNamespace "urn:us:gov:ic:usagency"
arhNamespace: &arhNamespace "urn:us:gov:ic:arh"
edhNamespace: &edhNamespace "urn:us:gov:ic:edh"
icidNamespace: &icidNamespace "urn:us:gov:ic:id"

# Mapping from STANAG 5636->IC-EDH
stanag-icedh-mappings: &stanag-icedh-mappings
  mappingExpressions:
    - type: LITERAL
      value: "202111"
      targets:
        - namespace: *edhNamespace
          path: "Edh.DESVersion"
    - type: LITERAL
      value: "202111"
      targets:
        - namespace: *ismNamespace
          path: "Edh.DESVersion"
    - type: LITERAL
      value: "202205"
      targets:
        - namespace: *ismNamespace
          path: "Edh.ISMCATCESVersion"
    - type: LITERAL
      value: "202111"
      targets:
        - namespace: "urn:us:gov:ic:ntk"
          path: "Edh.DESVersion"
    - type: LITERAL
      value: "202207"
      targets:
        - namespace: *arhNamespace
          path: "Edh.DESVersion"
        - namespace: *arhNamespace
          path: "Edh.Security.DESVersion"
    - type: LITERAL
      value: "202100"
      targets:
        - path: "Edh.DESVersion"
          namespace: *icidNamespace
    - type: LITERAL
      value: "202207"
      targets:
        - path: "Edh.CESVersion"
          namespace: *agencyNamespace
    - type: AUTOGENERATED_DATETIME
      targets:
        - path: "Edh.DataItemCreateDateTime"
    - type: JSONPATH
      # STANAG confidential label category named Releasable To
      value: "$.ocl.cls"
      targets:
        - path: "Edh.Security.classification"
          namespace: *ismNamespace
          mappings: *ic-edh-cls-mappings
        - path: "Edh.Security.Access.classification"
          namespace: *ismNamespace
          mappings: *ic-edh-cls-mappings
    - type: JSONPATH
      # STANAG confidential label category named Releasable -> ism:releasableTo
      value: "$.ocl.catl[?(@.name == 'Releasable To')].vals"
      targets:
        - path: "Edh.Security.Access.releasableTo"
          namespace: *ismNamespace
    - type: JSONPATH
      # STANAG confidential label category named Restricted To Compartments  -> ism:SCIControls
      value: "$.ocl.catl[?(@.name == 'Restricted To Compartments')].vals"
      targets:
        - path: "Edh.Security.Access.SCIcontrols"
          namespace: *ismNamespace
    - type: LITERAL
      value: "REL"
      targets:
        - path: "Edh.Security.Access.disseminationControls"
          namespace: *ismNamespace

# Responsible for consuming input content and extracting content
contentExtractors:
  # Processor Type: "tika-content-extraction" processor: loading the
  #   standard tika content extraction processor
  - type: "tika-content-extraction"
    id: "std-content-extraction"
    ocr: true
    tikaServerUrl: "http://localhost:9998"
    # tikaClientTimeout: "30s" #configure the timeout for the http client that calls tika
  # Processor Type: "titus-metadata" processor: Introspects Content
  #   metadata for base64 encoded Titus Metadata (JSON)
  - type: "titus-metadata"
    id: "titus-metadata-extractor-email"
    metadataKeys:
      - "Message:Raw-Header:x-titus-metadata-40"

# Creates tags from extracted content. e.g. regex: Produce tags based on
# regex matching.  Each processor in the flow is identified by standard
# configuration properties:
#   id: unique ID of the processor, used primarily in provenance tracking
#   type: a well known type used to discover the processor at runtime.
#         The discovery process first checks for well known standard
#         processors then falls back to processor discovery using
#         META-INF/taggingproviders and processor specific configuration.
tagExtractionRules:
  # The TDF ZIP attribute extractor
  - id: "tdf3"
    type: "tdf3-tag-processor"
  # The TDF XML attribute extractor
  - id: "tdfxml_extraction"
    type: "tdfxml"
    ztdfClassificationTemplate:
      tagTemplates:
        - type: "ATTRIBUTE"
          synonymDictionary: "classification-dict"
          namespace: *classificationAttributeFQN
    ztdfRelToTemplate:
      tagTemplates:
        - type: "ATTRIBUTE"
          namespace: *relToAttributeFQN
    ictdfEDHSecAccessMappings: *icEDHSecAccessMappings
  - id: "ic-edh-processor"
    type: "ic-edh"
    icEDHSecAccessMappings: *icEDHSecAccessMappings
    icEDHSecMappings: *icEDHSecAccessMappings
  # The xheader_bj_releasability tag processor is used to parse the Boldon
  # James 'classification' property (x-bj_classification) from email headers
  - id: "xheader_bj_classification"
    # Processor Type: "regex" processor: Applies regex tag extraction rules
    type: "regex"
    # Scope: Filter content items for evaluation of the regex expression.
    # In this example Filter:
    # - Only process email items = message/rfc822
    # - Then only metadata values for email items with a metadata key value
    #   having a regex match
    scope:
      # only considers content items of type "message/rfc822" (email)
      itemTypes: [ "message/rfc822" ]
      # Only regex on metadata values for key matching the regex
      contentEval:
        sources: ["METADATA"]
        metadataFilters:
          # Process metadata values based on key match of the following regex
          - keyRegex: >-
              (?i)x-bj_classification
    # textProcessingMode: 3 options
    # - ALL (default): Process ALL Text
    # - FIRST_LINE: Process only the first line
    # - N_LINES: Process only the first N Lines
    #   - must be accompanied by:
    #      nLines: <number>
    textProcessingMode: ALL
    # stopMode: 2 options - When should the regex processor stop adding tags:
    # - NONE (default) - does not stop
    # - FIRST_MATCH - stops after first match
    stopMode: NONE
    # The regex Expression - uses capture groups to inform tag creation below
    regex: >-
      (?:\W*(?:([A-Z- ]+)(?:[\W]+|$)))*
    captureGroups:
      # For Capture Group 1 create both a TDF Attribute and TDF Assertion.
      # A synonym dictionary is used to map values->well known terms.
      - group: "1"
        tagTemplates:
          - type: "ATTRIBUTE"
            synonymDictionary: "classification-dict"
            namespace: *classificationAttributeFQN
  # The xheader_bj_releasability tag processor is used to parse the Boldon
  # James 'releasability' property (x-bj_releasability) from email headers
  - id: "xheader_bj_releasability"
    # Processor Type: "regex" processor: Applies regex tag extraction rules
    type: "regex"
    # Scope: Filter content items for evaluation of the regex expression.
    # In this example Filter:
    # - Only process email items = message/rfc822
    # - Then only metadata values for email items with a metadata key
    #   value having a regex match
    scope:
      # only considers content items of type "message/rfc822" (email)
      itemTypes: [ "message/rfc822" ]
      # Only regex on metadata values for key matching the regex
      contentEval:
        sources: ["METADATA"]
        metadataFilters:
          # only process metadata values based on key match of the
          # following regex
          - keyRegex: >-
              (?i)x-bj_releasability
    # textProcessingMode: 3 options
    # - ALL (default): Process ALL Text
    # - FIRST_LINE: Process only the first line
    # - N_LINES: Process only the first N Lines
    #   - must be accompanied by:
    #      nLines: <number>
    textProcessingMode: ALL
    # stopMode: 2 options - When should the regex processor stop adding tags:
    # - NONE (default) - does not stop
    # - FIRST_MATCH - stops after first match
    stopMode: NONE
    # The regex Expression - uses capture groups to inform tag creation below
    regex: >-
      (\b[A-Z]{2,4}\b(?:[ ,]+\b[A-Z]{2,4}\b)*)
    captureGroups:
      # For Capture Group 1 create both a TDF Attribute and TDF Assertion.
      # A synonym dictionary is used to map values->well known terms.
      - group: "1"
        # optional delimiters to apply to this capture group
        delimiters: [", ", ";", " "]
        tagTemplates:
          - type: "ATTRIBUTE"
            namespace: *relToAttributeFQN
            synonymDictionary: "relto-dict"
  # The classification-banners tag processor is used to parse single line
  # banner type classifications
  - id: "classification-banners"
    desc: "Extract Classification, Need to Know and Releasability Tags"
    # Scope: Filter content items for evaluation of the regex expression.
    # In this example Filter:
    # - Scope to only BODY
    scope:
      contentEval:
        sources:
          - BODY
    # Processor Type: "regex" processor: Applies regex tag extraction rules
    type: "regex"
    # textProcessingMode: 3 options
    # - ALL (default): Process ALL Text
    # - FIRST_LINE: Process only the first line
    # - N_LINES: Process only the first N Lines
    #   - must be accompanied by:
    #      nLines: <number>
    textProcessingMode: ALL
    # stopMode: 2 options - When should the regex processor stop adding tags:
    # - NONE (default) - does not stop
    # - FIRST_MATCH - stops after first match
    stopMode: NONE
    # The regex Expression - uses capture groups to inform tag creation below
    regex: >-
      (?i)(TOP SECRET|TOPSECRET|TS|SECRET|SEC|S|CONFIDENTIAL|C|OFFICIAL-SENSITIVE|OFFICIAL|CONTROLLED UNCLASSIFIED|CUI|UNCLASSIFIED|U)[\W]*(\b(?:[/ ]?\b[a-zA-Z]{2,4}\b)*)(?:[\W]+Rel(?:easable)?[\W]*(?:To)?)[\W]*(\b[a-zA-Z]{2,4}\b(?:[ ,]+\b[a-zA-Z]{2,4}\b)*)
    captureGroups:
      # For Capture Group 1 create both a TDF Attribute and TDF Assertion.
      # A synonym dictionary is used to map values->well known terms.
      - group: "1"
        tagTemplates:
          - type: "ATTRIBUTE"
            synonymDictionary: "classification-dict"
            namespace: *classificationAttributeFQN
      # For Capture Group 2 create both a TDF Attribute and TDF Assertion.
      - group: "2"
        # optional delimiters to apply to this capture group
        delimiters: [", ", ";", " ", "/"]
        tagTemplates:
          - type: "ATTRIBUTE"
            namespace: *needToKnowAttributeFQN
      # For Capture Group 3 create both a TDF Attribute and TDF Assertion.
      # A synonym dictionary is used to map values->well known terms.
      - group: "3"
        # optional delimiters to apply to this capture group
        delimiters: [", ", ";", " "]
        tagTemplates:
          - type: "ATTRIBUTE"
            namespace: *relToAttributeFQN
            synonymDictionary: "relto-dict"
  # The classification-only-banners tag processor is used to parse
  # Classification only banners
  - id: "classification-only-banners"
    desc: "Extract Classification Only Tags"
    # Processor Type: "regex" processor: Applies regex tag extraction rules
    type: "regex"
    # Scope: Filter content items for evaluation of the regex expression.
    # In this example Filter:
    # - Scope to only BODY
    scope:
      contentEval:
        sources:
          - BODY
    # textProcessingMode: 3 options
    # - ALL (default): Process ALL Text
    # - FIRST_LINE: Process only the first line
    # - N_LINES: Process only the first N Lines
    #   - must be accompanied by:
    #      nLines: <number>
    textProcessingMode: FIRST_LINE
    # stopMode: 2 options - When should the regex processor stop adding tags:
    # - NONE (default) - does not stop
    # - FIRST_MATCH - stops after first match
    stopMode: NONE
    # The regex Expression - uses capture groups to inform tag creation below
    regex: >-
      \b(?i)(TOP SECRET|TS|SECRET|SEC|S|CONFIDENTIAL|C|OFFICIAL-SENSITIVE|OFFICIAL|CONTROLLED UNCLASSIFIED|CUI|UNCLASSIFIED|U)(\W+|$)
    captureGroups:
      # For Capture Group 1 create both a TDF Attribute and TDF Assertion.
      # In both cases a synonym dictionary is used to map values->well known terms.
      - group: "1"
        tagTemplates:
          - type: "ATTRIBUTE"
            synonymDictionary: "classification-dict"
            namespace: *classificationAttributeFQN
  # Alternate Data Stream Classification tag processor is used to parse
  # Classification from Alternate Data Stream
  - id: "Alternate Data Stream Classification"
    desc: "Read alternate data stream Classification"
    # Processor Type: "regex" processor: Applies regex tag extraction rules
    type: "regex"
    # Scope: Filter content items for evaluation of the regex expression.
    # In this example Filter:
    # - Scope to only BODY
    scope:
      contentEval:
        sources:
          - BODY
    # textProcessingMode: 3 options
    # - ALL (default): Process ALL Text
    # - FIRST_LINE: Process only the first line
    # - N_LINES: Process only the first N Lines
    #   - must be accompanied by:
    #      nLines: <number>
    textProcessingMode: ALL
    # stopMode: 2 options - When should the regex processor stop adding tags:
    # - NONE (default) - does not stop
    # - FIRST_MATCH - stops after first match
    stopMode: NONE
    # The regex Expression - uses capture groups to inform tag creation below
    regex: >-
      (?i)<m:Classification value=\"(.+?)\">
    captureGroups:
      # For Capture Group 1 create both a TDF Attribute and TDF Assertion.
      # In both cases a synonym dictionary is used to map values->well known terms.
      - group: "1"
        tagTemplates:
          - type: "ATTRIBUTE"
            synonymDictionary: "classification-dict"
            namespace: *classificationAttributeFQN
  # Alternate Data Stream Releasability tag processor is used to parse
  # Releasability from Alternate Data Stream
  - id: "Alternate Data Stream Releasability"
    desc: "Read alternate data stream Releasability"
    # Processor Type: "regex" processor: Applies regex tag extraction rules
    type: "regex"
    # Scope: Filter content items for evaluation of the regex expression.
    # In this example Filter:
    # - Scope to only BODY
    scope:
      contentEval:
        sources:
          - BODY
    # textProcessingMode: 3 options
    # - ALL (default): Process ALL Text
    # - FIRST_LINE: Process only the first line
    # - N_LINES: Process only the first N Lines
    #   - must be accompanied by:
    #      nLines: <number>
    textProcessingMode: ALL
    # stopMode: 2 options - When should the regex processor stop adding tags:
    # - NONE (default) - does not stop
    # - FIRST_MATCH - stops after first match
    stopMode: NONE
    # The regex Expression - uses capture groups to inform tag creation below
    regex: >-
      (?i)<m:Releasability value=\"(.+?)\">
    captureGroups:
      # For Capture Group 1 create both a TDF Attribute and TDF Assertion.
      # A synonym dictionary is used to map values->well known terms.
      - group: "1"
        # optional delimiters to apply to this capture group
        delimiters: [", ", ";", " "]
        tagTemplates:
          - type: "ATTRIBUTE"
            namespace: *relToAttributeFQN
            synonymDictionary: "relto-dict"
  # The titus-classification-markings tag processor is used to parse
  # Titus classification markings
  - id: "titus-classification-markings"
    desc: "Map titus classification markings"
    # Processor Type: "regex" processor: Applies regex tag extraction rules
    type: "regex"
    # Scope: Filter content items for evaluation of the regex expression.
    # In this example Filter:
    # - Scope to all content types having a metadata field custom:TitusGUID
    #   AND
    # - use metadata value custom:Classification as source of tag extraction
    scope:
      metadataFilters:
        - keys: ["custom:TitusGUID"]
      contentEval:
        sources: ["METADATA"]
        metadataFilters:
          - keys: ["custom:Classification"]
    # textProcessingMode: 3 options
    # - ALL (default): Process ALL Text
    # - FIRST_LINE: Process only the first line
    # - N_LINES: Process only the first N Lines
    #   - must be accompanied by:
    #      nLines: <number>
    textProcessingMode: ALL
    # stopMode: 2 options - When should the regex processor stop adding tags:
    # - NONE (default) - does not stop
    # - FIRST_MATCH - stops after first match
    stopMode: NONE
    # The regex Expression - uses capture groups to inform tag creation below
    regex: >-
      (\b\w+\b(?:[,|;|\s]+\b\w+\b)*)
    captureGroups:
      # For Capture Group 1 create both a TDF Attribute and TDF Assertion.
      # A synonym dictionary is used to map values->well known terms.
      - group: "1"
        # optional delimiters to apply to this capture group
        delimiters: [", ", ";"]
        tagTemplates:
          - type: "ATTRIBUTE"
            synonymDictionary: "classification-dict"
            namespace: *classificationAttributeFQN
  # The titus-releasability-markings tag processor is used to parse
  # Titus releasability markings
  - id: "titus-releasability-markings"
    desc: "Map titus releasability markings"
    # Processor Type: "regex" processor: Applies regex tag extraction rules
    type: "regex"
    # Scope: Filter content items for evaluation of the regex expression.
    # In this example Filter:
    # - Scope to all content types having a metadata field custom:TitusGUID
    #   AND
    # - use metadata value custom:Releasability as source of tag extraction
    scope:
      metadataFilters:
        - keys: ["custom:TitusGUID"]
      contentEval:
        sources: ["METADATA"]
        metadataFilters:
          - keys: ["custom:Releasability"]
    # textProcessingMode: 3 options
    # - ALL (default): Process ALL Text
    # - FIRST_LINE: Process only the first line
    # - N_LINES: Process only the first N Lines
    #   - must be accompanied by:
    #      nLines: <number>
    textProcessingMode: ALL
    # stopMode: 2 options - When should the regex processor stop adding tags:
    # - NONE (default) - does not stop
    # - FIRST_MATCH - stops after first match
    stopMode: NONE
    # The regex Expression - uses capture groups to inform tag creation below
    regex: >-
      (\b\w+\b(?:[,|;|\s]+\b\w+\b)*)
    captureGroups:
      # For Capture Group 1 create both a TDF Attribute and TDF Assertion.
      # In both cases a synonym dictionary is used to map values->well known terms.
      - group: "1"
        # optional delimiters to apply to this capture group
        delimiters: [", ", ";", " "]
        tagTemplates:
          - type: "ATTRIBUTE"
            namespace: *relToAttributeFQN
            synonymDictionary: "relto-dict"
  # The boldonJames-classification-markings tag processor is used to parse
  # Titus classification markings
  - id: "boldonJames-classification-markings"
    desc: "Map boldonJames classification markings"
    # Processor Type: "regex" processor: Applies regex tag extraction rules
    type: "regex"
    # Scope: Filter content items for evaluation of the regex expression.
    # In this example Filter:
    # - Scope to all content types having a metadata field custom:TitusGUID
    #   AND
    # - use metadata value custom:Classification as source of tag extraction
    scope:
      metadataFilters:
        - keys: ["custom:bjSaver"]
      contentEval:
        sources: ["METADATA"]
        metadataFilters:
          - keys: ["custom:Classification"]
    # textProcessingMode: 3 options
    # - ALL (default): Process ALL Text
    # - FIRST_LINE: Process only the first line
    # - N_LINES: Process only the first N Lines
    #   - must be accompanied by:
    #      nLines: <number>
    textProcessingMode: ALL
    # stopMode: 2 options - When should the regex processor stop adding tags:
    # - NONE (default) - does not stop
    # - FIRST_MATCH - stops after first match
    stopMode: NONE
    # The regex Expression - uses capture groups to inform tag creation below
    regex: >-
      (\b\w+\b(?:[,|;|\s]+\b\w+\b)*)
    captureGroups:
      # For Capture Group 1 create both a TDF Attribute and TDF Assertion.
      # In both cases a synonym dictionary is used to map values->well known terms.
      - group: "1"
        # optional delimiters to apply to this capture group
        delimiters: [", ", ";"]
        tagTemplates:
          - type: "ATTRIBUTE"
            synonymDictionary: "classification-dict"
            namespace: *classificationAttributeFQN
  # The boldonJames-releasability-markings tag processor is used to parse
  # Titus releasability markings
  - id: "boldonJames-releasability-markings"
    desc: "Map boldonJames releasability markings"
    # Processor Type: "regex" processor: Applies regex tag extraction rules
    type: "regex"
    # Scope: Filter content items for evaluation of the regex expression.
    # In this example Filter:
    # - Scope to all content types having a metadata field custom:TitusGUID
    #   AND
    # - use metadata value custom:Releasability as source of tag extraction
    scope:
      metadataFilters:
        - keys: ["custom:bjSaver"]
      contentEval:
        sources: ["METADATA"]
        metadataFilters:
          - keys: ["custom:Releasability"]
    # textProcessingMode: 3 options
    # - ALL (default): Process ALL Text
    # - FIRST_LINE: Process only the first line
    # - N_LINES: Process only the first N Lines
    #   - must be accompanied by:
    #      nLines: <number>
    textProcessingMode: ALL
    # stopMode: 2 options - When should the regex processor stop adding tags:
    # - NONE (default) - does not stop
    # - FIRST_MATCH - stops after first match
    stopMode: NONE
    # The regex Expression - uses capture groups to inform tag creation below
    regex: >-
      (\b\w+\b(?:[,|;|\s]+\b\w+\b)*)
    captureGroups:
      # For Capture Group 1 create both a TDF Attribute and TDF Assertion.
      # In both cases a synonym dictionary is used to map values->well known terms.
      - group: "1"
        # optional delimiters to apply to this capture group
        delimiters: [", ", ";", " "]
        tagTemplates:
          - type: "ATTRIBUTE"
            namespace: *relToAttributeFQN
            synonymDictionary: "relto-dict"
tagProcessors:
  # This is the standard type for the required tag processor.
  - type: required-tags
    id: "missing required tag"
    # The tag type used when generating a new tag missing values
    tagType: "MISSING_REQUIRED_TAG"
    # The processing scope. ITEM or GLOBAL.  Default is ITEM.
    # ITEM Scope = tags must exist across all content items
    processingScope: GLOBAL
    # The namespaces of the required tags
    requiredNamespaces: [*classificationAttributeFQN,
                         *relToAttributeFQN]
    # Content types should have metadata treated as a separate input requirement
    requireMetadataTypes: ["message/rfc822"]
    # Dynamic value that's injected.
    tagValue: "virtru:block"
  - id: "test tag mismatch between tags in an (email body or header) and an email attachment"
    type: tag-mismatch
    inputs:
      # Any type, any value, Has source from email header OR an email body
      - tagTypes: []
        tagValues: []
        tagSources:
          - itemTypes: ["message/rfc822"]
            itemIdRegex: >-
              Message:Raw-Header
          - itemTypes: ["message/rfc822"]
      # Any tag from an email attachment
      - tagTypes: []
        tagValues: []
        tagSources:
          - itemTypes: ["message/rfc822.attachment"]
    tagTemplate:
      value: "virtru:warn"
      type: "tag-mismatch"

# Reduces tag set
rollupRules:
  # Processor Type: "std-rollup" processor:
  # - Rolls up tags based on attribute definitions
  # - Rolls up restrictive ("allOf") tags across all content sources as a "union".
  # - Rolls up permissive ("anyOf") tags across all content sources as an "intersection"; Optional group aliases are used here.
  # - Rolls up "hierarchy" tags using a "High Watermark" approach.
  # - Case-insensitive matching on attribute values. Case is corrected when attribute definitions exists for the given tag value
  # - Values not matching an attribute definition are allowed to pass through (default behavior)

  - type: "std-rollup"
    id: "standard rollup"
    # Treat items of type "message/rfc822" (email) message metadata as a separate bucket of content
    metadataItemTypes: ["message/rfc822"]
    # Should intra-content items be rolled up - default is false
    intraContentRollup: true
    # aliasRollupMode: 3 options  Control mode for handling aliases
    # - BOTH = Default, both an alias and its members are kept after rollup rules are applied
    # - ALIAS = only the alias value is kept and members are dropped after rollup rules are applied.  Only if all members are present for the alias
    # - MEMBER = drops an alias value if all member values are present.
    aliasRollupMode: ALIAS
    # Require a rollup alias to appear at least once in the intersected value list - default = false
    requireAliasInValues: false
    # Control behavior when ANYOF attributes have no intersection across content items
    # - true: Return an error when no intersection exists
    # - false: (default) Allow operation to continue (may inject null value if InjectMissingIntersectionAttribute is true)
    # errorOnEmptyIntersection: true
    # Whether to inject a null value when no intersection exists (default = true for backward compatibility)
    # injectMissingIntersectionAttribute: true
    # The value to inject when no intersection exists (default = "null")
    # missingIntersectionAttributeValue: "null"
    # Group aliases
    attributeValueMembers:
      - value:
          fqn: "https://demo.com/attr/relto/value/FVEY"
        members:
          - value: "USA"
          - value: "GBR"
          - value: "AUS"
          - value: "NZL"
          - value: "CAN"
      - value:
          fqn: "https://demo.com/attr/relto/value/PINK"
        members:
          - value: "USA"
          - value: "GBR"
          - value: "AUS"
          - value: "CAN"
          - value: "NZL"
          - value: "BEL"
          - value: "DNK"
          - value: "FRA"
          - value: "ITA"
          - value: "NOR"
          - value: "PRT"
          - value: "HRV"
          - value: "CZE"
          - value: "POL"
          - value: "ROU"
          - value: "DEU"
          - value: "ESP"
          - value: "TUR"
          - value: "SWE"
          - value: "FIN"
          - value: "AUT"

      - value:
          fqn: "https://demo.com/attr/relto/value/NATO"
        members:
          - value: "ALB"
          - value: "BEL"
          - value: "BGR"
          - value: "CAN"
          - value: "HRV"
          - value: "CZE"
          - value: "DNK"
          - value: "EST"
          - value: "FRA"
          - value: "DEU"
          - value: "GRC"
          - value: "HUN"
          - value: "ISL"
          - value: "ITA"
          - value: "LVA"
          - value: "LTU"
          - value: "LUX"
          - value: "MNE"
          - value: "NLD"
          - value: "MKD"
          - value: "NOR"
          - value: "POL"
          - value: "PRT"
          - value: "ROU"
          - value: "SVK"
          - value: "SVN"
          - value: "ESP"
          - value: "TUR"
          - value: "GBR"
          - value: "USA"

    attributeDefs: &rollup_attribute_defs
      - namespace:
          fqn: "https://demo.com"
        name: "classification"
        rule: *ATTRIBUTE_RULE_TYPE_ENUM_HIERARCHY
        values:
          - value: "topsecret"
          - value: "secret"
          - value: "confidential"
          - value: "unclassified"
      - namespace:
          fqn: "https://demo.com"
        name: "needToKnow"
        rule: *ATTRIBUTE_RULE_TYPE_ENUM_ALL_OF
        values:
          - value: INT
          - value: OPS
      - namespace:
          fqn: "https://demo.com"
        name: "relto"
        fqn: "https://demo.com/attr/relto"
        rule: *ATTRIBUTE_RULE_TYPE_ENUM_ANY_OF
        values:
          - value: "USA"
          - value: "GBR"
          - value: "CAN"
          - value: "AUS"
          - value: "NZL"
          - value: "FRA"
          - value: "UKR"
          - value: "FVEY"
          - value: "NATO"
          - value: "PINK"
          - value: "DEU"
          - value: "FIN"
          - value: "CZE"
          - value: "DNK"
          - value: "FRA"
          - value: "DEU"
          - value: "GRC"
          - value: "HUN"
          - value: "ISL"
          - value: "ITA"
          - value: "LUX"
          - value: "NLD"
          - value: "NOR"
          - value: "POL"
          - value: "PRT"
          - value: "ESP"
          - value: "TUR"
          - value: "BGR"
          - value: "EST"
          - value: "LVA"
          - value: "LTU"
          - value: "ROU"
          - value: "SVK"
          - value: "SVN"
          - value: "BEL"
          - value: "HRV"
          - value: "SWE"
          - value: "AUT"
          - value: "ALB"
          - value: "MNE"
          - value: "MKD"

    # Link non attributes to attributes for rollup
    tagLinks:
      - src: "Classification"
        target: *classificationAttributeFQN
      - src: "needToKnow"
        target: *needToKnowAttributeFQN
      - src: "releasableTo"
        target: *relToAttributeFQN

  # Processor Type: "drop-duplicates" processor: Merges duplicate tags
  - type: "drop-duplicates"
    id: "drop duplicate values"
  - type: stanag5636-assertions
    id: "urn:nato:stanag:5636:A:1:elements:json"
    assertionType: "urn:nato:stanag:5636:A:1:elements:json"
    assertionFormat: "json+stanag5636"
    attributeInputs: *snag5636-attributeInputs
    icedhAssertionType: *edhNamespace
    # Validation ~ min required metadata fields
    requiredMetadata:
      name: "fvey-minimum-metadata-example"
      jsonPathExpressions:
        # require a "releasable to" conf. label category
        - "$.ocl.catl[?(@.name == 'Releasable To')]"
        # require policy identifier
        - "$.ocl.pol"
        # require classification
        - "$.ocl.cls"
        # require date created
        - "$.ocl.dcr"
    attributeDefs: *rollup_attribute_defs

  - type: icedh-assertions
    id: *edhNamespace
    assertionType: *edhNamespace
    assertionFormat: "ic-edh+xml"
    # generate assertion only when requested
    requireAssertionOption: true
    mappings: *stanag-icedh-mappings
