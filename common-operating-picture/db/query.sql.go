// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: query.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
	geos "github.com/twpayne/go-geos"
)

const deleteTdfObject = `-- name: DeleteTdfObject :one
DELETE FROM tdf_objects
WHERE id = $1
RETURNING id, ts, src_type, geo, search, tdf_blob, tdf_uri, _created_at, _created_by
`

// DeleteTdfObject
//
//	DELETE FROM tdf_objects
//	WHERE id = $1
//	RETURNING id, ts, src_type, geo, search, tdf_blob, tdf_uri, _created_at, _created_by
func (q *Queries) DeleteTdfObject(ctx context.Context, id uuid.UUID) (TdfObject, error) {
	row := q.db.QueryRow(ctx, deleteTdfObject, id)
	var i TdfObject
	err := row.Scan(
		&i.ID,
		&i.Ts,
		&i.SrcType,
		&i.Geo,
		&i.Search,
		&i.TdfBlob,
		&i.TdfUri,
		&i.CreatedAt,
		&i.CreatedBy,
	)
	return i, err
}

const getSrcType = `-- name: GetSrcType :one
SELECT id, form_schema, ui_schema, metadata
FROM src_types
WHERE id = $1
`

// GetSrcType
//
//	SELECT id, form_schema, ui_schema, metadata
//	FROM src_types
//	WHERE id = $1
func (q *Queries) GetSrcType(ctx context.Context, id string) (SrcType, error) {
	row := q.db.QueryRow(ctx, getSrcType, id)
	var i SrcType
	err := row.Scan(
		&i.ID,
		&i.FormSchema,
		&i.UiSchema,
		&i.Metadata,
	)
	return i, err
}

const getTdfObject = `-- name: GetTdfObject :one
SELECT id, ts, src_type, ST_Centroid(geo)::GEOMETRY AS geo, search, tdf_blob, tdf_uri
FROM tdf_objects 
WHERE
  id = $1
LIMIT 1
`

type GetTdfObjectRow struct {
	ID      uuid.UUID        `json:"id"`
	Ts      pgtype.Timestamp `json:"ts"`
	SrcType string           `json:"src_type"`
	Geo     interface{}      `json:"geo"`
	Search  []byte           `json:"search"`
	TdfBlob []byte           `json:"tdf_blob"`
	TdfUri  pgtype.Text      `json:"tdf_uri"`
}

// GetTdfObject
//
//	SELECT id, ts, src_type, ST_Centroid(geo)::GEOMETRY AS geo, search, tdf_blob, tdf_uri
//	FROM tdf_objects
//	WHERE
//	  id = $1
//	LIMIT 1
func (q *Queries) GetTdfObject(ctx context.Context, id uuid.UUID) (GetTdfObjectRow, error) {
	row := q.db.QueryRow(ctx, getTdfObject, id)
	var i GetTdfObjectRow
	err := row.Scan(
		&i.ID,
		&i.Ts,
		&i.SrcType,
		&i.Geo,
		&i.Search,
		&i.TdfBlob,
		&i.TdfUri,
	)
	return i, err
}

const listSrcTypes = `-- name: ListSrcTypes :many
SELECT id
FROM src_types
`

// ListSrcTypes
//
//	SELECT id
//	FROM src_types
func (q *Queries) ListSrcTypes(ctx context.Context) ([]string, error) {
	rows, err := q.db.Query(ctx, listSrcTypes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var id string
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTdfObjects = `-- name: ListTdfObjects :many
SELECT id, ts, src_type, ST_Centroid(geo)::GEOMETRY AS geo, search, tdf_blob, tdf_uri
FROM tdf_objects
WHERE src_type = $1::TEXT AND ts >= $2::TIMESTAMP AND ts <= $3::TIMESTAMP
ORDER BY ts DESC
`

type ListTdfObjectsParams struct {
	SourceType string           `json:"source_type"`
	StartTime  pgtype.Timestamp `json:"start_time"`
	EndTime    pgtype.Timestamp `json:"end_time"`
}

type ListTdfObjectsRow struct {
	ID      uuid.UUID        `json:"id"`
	Ts      pgtype.Timestamp `json:"ts"`
	SrcType string           `json:"src_type"`
	Geo     interface{}      `json:"geo"`
	Search  []byte           `json:"search"`
	TdfBlob []byte           `json:"tdf_blob"`
	TdfUri  pgtype.Text      `json:"tdf_uri"`
}

// ListTdfObjects
//
//	SELECT id, ts, src_type, ST_Centroid(geo)::GEOMETRY AS geo, search, tdf_blob, tdf_uri
//	FROM tdf_objects
//	WHERE src_type = $1::TEXT AND ts >= $2::TIMESTAMP AND ts <= $3::TIMESTAMP
//	ORDER BY ts DESC
func (q *Queries) ListTdfObjects(ctx context.Context, arg ListTdfObjectsParams) ([]ListTdfObjectsRow, error) {
	rows, err := q.db.Query(ctx, listTdfObjects, arg.SourceType, arg.StartTime, arg.EndTime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTdfObjectsRow
	for rows.Next() {
		var i ListTdfObjectsRow
		if err := rows.Scan(
			&i.ID,
			&i.Ts,
			&i.SrcType,
			&i.Geo,
			&i.Search,
			&i.TdfBlob,
			&i.TdfUri,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTdfObjectsWithGeo = `-- name: ListTdfObjectsWithGeo :many
SELECT id, ts, src_type, ST_Centroid(geo)::GEOMETRY AS geo, search, tdf_blob, tdf_uri
FROM tdf_objects
WHERE src_type = $1::TEXT AND ts >= $2::TIMESTAMP AND ts <= $3::TIMESTAMP
  AND ST_Within(geo, $4::GEOMETRY)
ORDER BY ts DESC
`

type ListTdfObjectsWithGeoParams struct {
	SourceType string           `json:"source_type"`
	StartTime  pgtype.Timestamp `json:"start_time"`
	EndTime    pgtype.Timestamp `json:"end_time"`
	Geometry   interface{}      `json:"geometry"`
}

type ListTdfObjectsWithGeoRow struct {
	ID      uuid.UUID        `json:"id"`
	Ts      pgtype.Timestamp `json:"ts"`
	SrcType string           `json:"src_type"`
	Geo     interface{}      `json:"geo"`
	Search  []byte           `json:"search"`
	TdfBlob []byte           `json:"tdf_blob"`
	TdfUri  pgtype.Text      `json:"tdf_uri"`
}

// ListTdfObjectsWithGeo
//
//	SELECT id, ts, src_type, ST_Centroid(geo)::GEOMETRY AS geo, search, tdf_blob, tdf_uri
//	FROM tdf_objects
//	WHERE src_type = $1::TEXT AND ts >= $2::TIMESTAMP AND ts <= $3::TIMESTAMP
//	  AND ST_Within(geo, $4::GEOMETRY)
//	ORDER BY ts DESC
func (q *Queries) ListTdfObjectsWithGeo(ctx context.Context, arg ListTdfObjectsWithGeoParams) ([]ListTdfObjectsWithGeoRow, error) {
	rows, err := q.db.Query(ctx, listTdfObjectsWithGeo,
		arg.SourceType,
		arg.StartTime,
		arg.EndTime,
		arg.Geometry,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTdfObjectsWithGeoRow
	for rows.Next() {
		var i ListTdfObjectsWithGeoRow
		if err := rows.Scan(
			&i.ID,
			&i.Ts,
			&i.SrcType,
			&i.Geo,
			&i.Search,
			&i.TdfBlob,
			&i.TdfUri,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTdfObjectsWithSearch = `-- name: ListTdfObjectsWithSearch :many
SELECT id, ts, src_type, ST_Centroid(geo)::GEOMETRY AS geo, search, tdf_blob, tdf_uri
FROM tdf_objects
WHERE src_type = $1::TEXT AND ts >= $2::TIMESTAMP AND ts <= $3::TIMESTAMP
  AND search @> $4::JSONB
ORDER BY ts DESC
`

type ListTdfObjectsWithSearchParams struct {
	SourceType string           `json:"source_type"`
	StartTime  pgtype.Timestamp `json:"start_time"`
	EndTime    pgtype.Timestamp `json:"end_time"`
	Search     []byte           `json:"search"`
}

type ListTdfObjectsWithSearchRow struct {
	ID      uuid.UUID        `json:"id"`
	Ts      pgtype.Timestamp `json:"ts"`
	SrcType string           `json:"src_type"`
	Geo     interface{}      `json:"geo"`
	Search  []byte           `json:"search"`
	TdfBlob []byte           `json:"tdf_blob"`
	TdfUri  pgtype.Text      `json:"tdf_uri"`
}

// ListTdfObjectsWithSearch
//
//	SELECT id, ts, src_type, ST_Centroid(geo)::GEOMETRY AS geo, search, tdf_blob, tdf_uri
//	FROM tdf_objects
//	WHERE src_type = $1::TEXT AND ts >= $2::TIMESTAMP AND ts <= $3::TIMESTAMP
//	  AND search @> $4::JSONB
//	ORDER BY ts DESC
func (q *Queries) ListTdfObjectsWithSearch(ctx context.Context, arg ListTdfObjectsWithSearchParams) ([]ListTdfObjectsWithSearchRow, error) {
	rows, err := q.db.Query(ctx, listTdfObjectsWithSearch,
		arg.SourceType,
		arg.StartTime,
		arg.EndTime,
		arg.Search,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTdfObjectsWithSearchRow
	for rows.Next() {
		var i ListTdfObjectsWithSearchRow
		if err := rows.Scan(
			&i.ID,
			&i.Ts,
			&i.SrcType,
			&i.Geo,
			&i.Search,
			&i.TdfBlob,
			&i.TdfUri,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTdfObjectsWithSearchAndGeo = `-- name: ListTdfObjectsWithSearchAndGeo :many
SELECT id, ts, src_type, ST_Centroid(geo)::GEOMETRY AS geo, search, tdf_blob, tdf_uri
FROM tdf_objects
WHERE src_type = $1::TEXT AND ts >= $2::TIMESTAMP AND ts <= $3::TIMESTAMP
  AND search @> $4::JSONB
  AND ST_Within(geo, $5::GEOMETRY)
ORDER BY ts DESC
`

type ListTdfObjectsWithSearchAndGeoParams struct {
	SourceType string           `json:"source_type"`
	StartTime  pgtype.Timestamp `json:"start_time"`
	EndTime    pgtype.Timestamp `json:"end_time"`
	Search     []byte           `json:"search"`
	Geometry   interface{}      `json:"geometry"`
}

type ListTdfObjectsWithSearchAndGeoRow struct {
	ID      uuid.UUID        `json:"id"`
	Ts      pgtype.Timestamp `json:"ts"`
	SrcType string           `json:"src_type"`
	Geo     interface{}      `json:"geo"`
	Search  []byte           `json:"search"`
	TdfBlob []byte           `json:"tdf_blob"`
	TdfUri  pgtype.Text      `json:"tdf_uri"`
}

// ListTdfObjectsWithSearchAndGeo
//
//	SELECT id, ts, src_type, ST_Centroid(geo)::GEOMETRY AS geo, search, tdf_blob, tdf_uri
//	FROM tdf_objects
//	WHERE src_type = $1::TEXT AND ts >= $2::TIMESTAMP AND ts <= $3::TIMESTAMP
//	  AND search @> $4::JSONB
//	  AND ST_Within(geo, $5::GEOMETRY)
//	ORDER BY ts DESC
func (q *Queries) ListTdfObjectsWithSearchAndGeo(ctx context.Context, arg ListTdfObjectsWithSearchAndGeoParams) ([]ListTdfObjectsWithSearchAndGeoRow, error) {
	rows, err := q.db.Query(ctx, listTdfObjectsWithSearchAndGeo,
		arg.SourceType,
		arg.StartTime,
		arg.EndTime,
		arg.Search,
		arg.Geometry,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTdfObjectsWithSearchAndGeoRow
	for rows.Next() {
		var i ListTdfObjectsWithSearchAndGeoRow
		if err := rows.Scan(
			&i.ID,
			&i.Ts,
			&i.SrcType,
			&i.Geo,
			&i.Search,
			&i.TdfBlob,
			&i.TdfUri,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTdfObject = `-- name: UpdateTdfObject :one
UPDATE tdf_objects
SET ts = $2,
    src_type = $3,
    geo = $4,
    search = $5,
    tdf_blob = $6,
    tdf_uri = $7
WHERE id = $1
RETURNING id, src_type, ts
`

type UpdateTdfObjectParams struct {
	ID      uuid.UUID        `json:"id"`
	Ts      pgtype.Timestamp `json:"ts"`
	SrcType string           `json:"src_type"`
	Geo     *geos.Geom       `json:"geo"`
	Search  []byte           `json:"search"`
	TdfBlob []byte           `json:"tdf_blob"`
	TdfUri  pgtype.Text      `json:"tdf_uri"`
}

type UpdateTdfObjectRow struct {
	ID      uuid.UUID        `json:"id"`
	SrcType string           `json:"src_type"`
	Ts      pgtype.Timestamp `json:"ts"`
}

// UpdateTdfObject
//
//	UPDATE tdf_objects
//	SET ts = $2,
//	    src_type = $3,
//	    geo = $4,
//	    search = $5,
//	    tdf_blob = $6,
//	    tdf_uri = $7
//	WHERE id = $1
//	RETURNING id, src_type, ts
func (q *Queries) UpdateTdfObject(ctx context.Context, arg UpdateTdfObjectParams) (UpdateTdfObjectRow, error) {
	row := q.db.QueryRow(ctx, updateTdfObject,
		arg.ID,
		arg.Ts,
		arg.SrcType,
		arg.Geo,
		arg.Search,
		arg.TdfBlob,
		arg.TdfUri,
	)
	var i UpdateTdfObjectRow
	err := row.Scan(&i.ID, &i.SrcType, &i.Ts)
	return i, err
}
